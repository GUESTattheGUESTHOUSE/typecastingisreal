use {
    once_cell::sync::Lazy,
    regex:RegexSet,
};

let set = RegexSet::new(&[
    r"[(struct)]",
    r"[(union)]",
    r"[(const)]",
    r"[(let)]",
    r"[(pub)]",
    r"[(dyn)]",
    r"[(ref)]",
    r"[(raw)]",
    r"[(trait)]",
    r"[(fn)]",
    r"[('static)]",
    r"[(impl)]",
    r"[(for)]",
    r"[(self)]",
    r"[(async)]",
    r"[(move)]",
    r"[(Fn)]",
    r"[(AsyncFn)]",
    r"[(return)]",
    r"[(true)]",
    r"[(unsafe)]",
    r"[(extern)]",
    r"[(while)]",
    r"[(loop)]",
    r"[(in)]",
    r"[(if)]",
    r"[(else)]",
    r"[('label)]",
    r"[(loop)]",
    r"[(break)]",
    r"[(continue)]",
    r"[(await)]",
    r"[(as)]",
    r"[(mod)]",
    r"[(crate)]",
    r"[(super)]",
    r"[(self)]",
    r"[(use)]",
    r"[(type)]",
    r"[(Self)]",
    r"[(Box)]",
    r"[(alloc)]",
    r"[(any)]",
    r"[(any)]",
    r"[(ascii)]",
    r"[(async_inter)]",
    r"[(backtrace)]",
    r"[(boxed)]",
    r"[(bstr)]",
    r"[(cell)]",
    r"[(char)]",
    r"[(cmp)]",
    r"[(collections)]",
    r"[(env)]",
    r"[(error)]",
    r"[(ffi)]",
    r"[(fmt)]",
    r"[(fs)]",
    r"[(future)]",
    r"[(hash)]",
    r"[(intrinsics)]",
    r"[(io)]",
    r"[(iter)]",
    r"[(marker)]",
    r"[(mem)]",
    r"[(net)]",
    r"[(ops)]",
    r"[(option)]",
    r"[(os)]",
    r"[(panic)]",
    r"[(path)]",
    r"[(pin)]",
    r"[(process)]",
    r"[(ptr)]",
    r"[(random)]",
    r"[(range)]",
    r"[(rc)]",
    r"[(result)]",
    r"[(simd)]",
    r"[(slice)]",
    r"[(str)]",
    r"[(string)]",
    r"[(sync)]",
    r"[(task)]",
    r"[(thread)]",
    r"[(time)]",
    r"[(vec)]",
    r"[(borrow)]",
    r"[(convert)]",
    r"[(fmt)]",
    r"[(intrinsics)]",
    r"[(option)]",
    r"[(result)]",
    r"[(array)]",
    r"[(bool)]",
    r"[(char)]",
    r"[(f128)]",
    r"[(f16)]",
    r"[(f32)]",
    r"[(f64)]",
    r"[(i64)]",
    r"[(i16)]",
    r"[(i8)]",
    r"[(i32)]",
    r"[(i64)]",
    r"[(i128)]",
    r"[(isize)]",
    r"[(never)]",
    r"[(pointer)]",
    r"[(reference)]",
    r"[(slice)]",
    r"[(tuple)]",
    r"[(u128)]",
    r"[(u16)]",
    r"[(u32)]",
    r"[(u8)]",
    r"[(u64)]",
    r"[(unit)]",
    r"[(usize)]",
    r"[(clone)]",
    r"[(default)]",
    r"[(future)]",
    r"[(hash)]",
    r"[(arch)]",
    r"[(assert)]",
    r"[(assert_eq)]",
    r"[(assert_matches)]",
    r"[(cfg)]",
    r"[(cfg_match)]",
    r"[(column)]",
    r"[(compile_error)]",
    r"[(concat)]",
    r"[(concat_bytes)]",
    r"[(concat_idents)]",
    r"[(const_format_args)]",
    r"[(dbg)]",
    r"[(debug_assert)]",
    r"[(debug_assert_eq)]",
    r"[(debug_assert_ne)]",
    r"[(eprint)]",
    r"[(eprintln)]",
    r"[(file)]",
    r"[(format)]",
    r"[(format_args)]",
    r"[(format_args_nl)]",
    r"[(include)]",
    r"[(is_x86_feature_detected)]",
    r"[(line)]",
    r"[(log_syntax)]",
    r"[(matches)]",
    r"[(module_path)]",
    r"[(option_env)]",
    r"[(pat)]",
    r"[(pin)]",
    r"[(prelude)]",
    r"[(print)]",
    r"[(println)]",
    r"[(stringify)]",
    r"[(thread_local)]",
    r"[(todo)]",
    r"[(trace_macros)]",
    r"[(try)]",
    r"[(unimplemented)]",
    r"[(unreachable)]",
    r"[(unsafe_binder)]",
    r"[(write)]",
    r"[(writeln)]",
    r"[(autodiff)]",
    r"[(hint)]",
    r"[(intrinsics)]",
    r"[(random)]",
    r"[(sync)]",
    r"[(MAX)]",
    r"[(MIN)]",
    r"[(UNIX_EPOCH)]",
    r"[(ONCE_INIT)]",
    r"[(ATOMIC_BOOL_INIT)]",
    r"[(ATOMIC_ISIZE_INIT)]",
    r"[(ATOMIC_USIZE_INIT)]",
    r"[(MAIN_SEPARATOR)]",
    r"[(MAIN_SEPARATOR_STR)]",
    r"[(TAU)]",
    r"[(SQRT_2)]",
    r"[(SQRT_3)]",
    r"[(PI)]",
    r"[(PHI)]",
    r"[(LOG2_E)]",
    r"[(LOG2_10)]",
    r"[(LOG10_E)]",
    r"[(LOG10_2)]",
    r"[(LN_2)]",
    r"[(LN_10)]",
    r"[(FRAC_PI_2)]",
    r"[(FRAC_PI_2)]",
    r"[(FRAC_PI_4)]",
    r"[(FRAC_PI_6)]",
    r"[(FRAC_PI_8)]",
    r"[(FRAC_2_PI)]",
    r"[(FRAC_2_SQRT_PI)]",
    r"[(FRAC_1_PI)]",
    r"[(FRAC_1_SQRT_2)]",
    r"[(FRAC_1_SQRT_2PI)]",
    r"[(FRAC_1_SQRT_3)]",
    r"[(FRAC_1_SQRT_PI)]",
    r"[(EGAMMA)]",
    r"[(E)]",
    r"[(num)]"])
    .unwrap();

let mut return_vec = Vec::new();

fn regexcounterpoc (&return_vec) -> &return_vec{
    static RE: Lazy<Regex> = Lazy::new(|| Regex::new(r"...").unwrap());
    &return_vec 
}
fn main() {
}
